{"version":3,"file":"main.cjs.js","sources":["../src/parser/parseHtml.ts","../index.ts"],"sourcesContent":["/**\n * @file html 解析\n */\n\nconst attribute =\n    /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`\nconst startTagOpen = new RegExp(`^<${qnameCapture}`)\nconst startTagClose = /^\\s*(\\/?)>/\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`)\nconst doctype = /^<!DOCTYPE [^>]+>/i\n\nexport type DomAttr = {\n    key: string\n    value: string | number | boolean\n}\n\nexport interface ASTNode {\n    tag: string\n    children: ASTNode[]\n    parent: ASTNode\n    attrs: DomAttr[]\n    type: number\n}\n\nexport interface TextNode extends ASTNode{\n    text: string\n}\n\n/**\n * 解析Html\n * @param html\n */\nexport const parseHTML: any = (html: string) => {\n    const stack: ASTNode[] = [],\n        TEXT_TYPE = 3\n\n    let currentParent: ASTNode,\n        root: ASTNode\n\n    /**\n     * 创建AST节点\n     */\n\n    const createASTElement = (tag: string, attrs: DomAttr[]) => {\n        return {\n            tag,\n            attrs,\n            children: [],\n            parent: null\n        }\n    }\n\n    /**\n     * 已经解析的标签置空\n     */\n\n    const advance = (n: number) => {\n        html = html.substring(n)\n    }\n\n    /**\n     * 判断是否为一个起始标签\n     */\n\n    const parseStartTag = () => {\n        const start = html.match(startTagOpen)\n        if (start) {\n            // <div><div><div/><div/> -> <div><div/><div/> -> <div/><div/>\n            const match: any = {\n                tag: [start[1]],\n                attrs: []\n            }\n            advance(start[0].length)\n            // 如果不是起始标签的结尾 一直匹配下去\n            let end, attr\n            while (\n                !(end = html.match(startTagClose)) &&\n                (attr = html.match(attribute))\n                ) {\n                // 匹配到属性 收集至attr数组中 截取原始的字符串\n                advance(attr[0].length)\n                match.attrs.push({\n                    key: attr[1],\n                    value: attr[3] || attr[4] || attr[5] || true,\n                })\n            }\n            if (end) {\n                advance(end[0].length)\n            }\n            return match\n        }\n        return false\n    }\n\n    /**\n     * 处理起始标签\n     * 创建AST Node\n     */\n\n    const start = (tag: string, attrs: []) => {\n        const node = createASTElement(tag, attrs)\n        if (!root) {\n            root = node\n        }\n        // 栈中有值 建立父子关系\n        if (currentParent) {\n            node.parent = currentParent\n            currentParent.children.push(node)\n        }\n        // 压入栈中，作为下一个元素的爹元素\n        stack.push(node)\n        currentParent = node\n    }\n\n    /**\n     * 处理结尾标签\n     */\n\n    const end = (tag) => {\n        stack.pop()\n        currentParent = stack[stack.length - 1]\n    }\n\n    /**\n     * 文本节点\n     */\n\n    const char = (text: string) => {\n        text = text.replace(/\\s/g, \"\");\n        text &&\n        currentParent.children.push({\n            type: TEXT_TYPE,\n            parent: currentParent,\n            text,\n        });\n    }\n\n    while (html) {\n        let textEnd = html.indexOf(\"<\")\n        if (textEnd === 0) {\n            // 有可能是<div/>\n            const endTagMatch = html.match(endTag)\n            if (endTagMatch) {\n                advance(endTagMatch[0].length)\n                end(endTagMatch[1])\n                continue\n            }\n            // <div>\n            const startTagMatch = parseStartTag()\n            // 匹配到起始标签\n            if (startTagMatch) {\n                start(startTagMatch.tag,startTagMatch.attrs)\n                continue\n            }\n        }\n        // 文本节点\n        if (textEnd > 0) {\n            let text = html.substring(0, textEnd) // get文本内容\n            if (text) {\n                char(text)\n                advance(text.length)\n            }\n        }\n    }\n    return root\n}","import {parseHTML} from \"./src/parser/parseHtml\";\n\nconsole.log(parseHTML('<div><span>hello yedi</span></div>'));"],"names":["attribute","ncname","qnameCapture","startTagOpen","RegExp","startTagClose","endTag","console","log","html","stack","currentParent","root","advance","n","substring","parseStartTag","start","match","tag","attrs","end","attr","length","push","key","value","node","children","parent","createASTElement","char","text","replace","type","textEnd","indexOf","endTagMatch","pop","startTagMatch","parseHTML"],"mappings":"aAIA,MAAMA,EACF,4EACEC,EAAS,+BACTC,EAAe,OAAOD,SAAcA,KACpCE,EAAe,IAAIC,OAAO,KAAKF,KAC/BG,EAAgB,aAChBC,EAAS,IAAIF,OAAO,QAAQF,WCRlCK,QAAQC,IDgCsB,CAACC,IAC3B,MAAMC,EAAmB,GAGzB,IAAIC,EACAC,EAMJ,MAaMC,EAAWC,IACbL,EAAOA,EAAKM,UAAUD,EAAE,EAOtBE,EAAgB,KAClB,MAAMC,EAAQR,EAAKS,MAAMf,GACzB,GAAIc,EAAO,CAEP,MAAMC,EAAa,CACfC,IAAK,CAACF,EAAM,IACZG,MAAO,IAIX,IAAIC,EAAKC,EACT,IAHAT,EAAQI,EAAM,GAAGM,UAIXF,EAAMZ,EAAKS,MAAMb,MAClBiB,EAAOb,EAAKS,MAAMlB,KAGnBa,EAAQS,EAAK,GAAGC,QAChBL,EAAME,MAAMI,KAAK,CACbC,IAAKH,EAAK,GACVI,MAAOJ,EAAK,IAAMA,EAAK,IAAMA,EAAK,KAAM,IAMhD,OAHID,GACAR,EAAQQ,EAAI,GAAGE,QAEZL,CACV,CACD,OAAO,CAAK,EAQVD,EAAQ,CAACE,EAAaC,KACxB,MAAMO,EAzDe,EAACR,EAAaC,KAC5B,CACHD,MACAC,QACAQ,SAAU,GACVC,OAAQ,OAoDCC,CAAiBX,EAAKC,GAC9BR,IACDA,EAAOe,GAGPhB,IACAgB,EAAKE,OAASlB,EACdA,EAAciB,SAASJ,KAAKG,IAGhCjB,EAAMc,KAAKG,GACXhB,EAAgBgB,CAAI,EAgBlBI,EAAQC,KACVA,EAAOA,EAAKC,QAAQ,MAAO,MAE3BtB,EAAciB,SAASJ,KAAK,CACxBU,KAjGQ,EAkGRL,OAAQlB,EACRqB,QACF,EAGN,KAAOvB,GAAM,CACT,IAAI0B,EAAU1B,EAAK2B,QAAQ,KAC3B,GAAgB,IAAZD,EAAe,CAEf,MAAME,EAAc5B,EAAKS,MAAMZ,GAC/B,GAAI+B,EAAa,CACbxB,EAAQwB,EAAY,GAAGd,QACnBc,EAAY,GAzBxB3B,EAAM4B,MACN3B,EAAgBD,EAAMA,EAAMa,OAAS,GAyB7B,QACH,CAED,MAAMgB,EAAgBvB,IAEtB,GAAIuB,EAAe,CACftB,EAAMsB,EAAcpB,IAAIoB,EAAcnB,OACtC,QACH,CACJ,CAED,GAAIe,EAAU,EAAG,CACb,IAAIH,EAAOvB,EAAKM,UAAU,EAAGoB,GACzBH,IACAD,EAAKC,GACLnB,EAAQmB,EAAKT,QAEpB,CACJ,CACD,OAAOX,CAAI,ECpKH4B,CAAU"}