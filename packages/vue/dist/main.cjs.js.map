{"version":3,"file":"main.cjs.js","sources":["../src/parser/parseHtml.ts","../src/parser/index.ts","../index.ts"],"sourcesContent":["/**\n * @file html 解析\n */\n\nconst attribute =\n    /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`\nconst startTagOpen = new RegExp(`^<${qnameCapture}`)\nconst startTagClose = /^\\s*(\\/?)>/\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`)\nconst doctype = /^<!DOCTYPE [^>]+>/i\n\nexport type DomAttr = {\n    key: string\n    value: string | number | boolean\n}\n\nexport interface ASTNode {\n    tag: string\n    children: ASTNode[]\n    parent: ASTNode\n    attrs: DomAttr[]\n    type: number\n}\n\nexport interface TextNode extends ASTNode{\n    text: string\n}\n\n/**\n * 解析Html\n * @param html\n */\nexport const parseHTML: any = (html: string) => {\n    const stack: ASTNode[] = [],\n        ELEMENT_TYPE = 1,\n        TEXT_TYPE = 3\n\n    let currentParent: ASTNode,\n        root: ASTNode\n\n    /**\n     * 创建AST节点\n     */\n\n    const createASTElement = (tag: string, attrs: DomAttr[]) => {\n        return {\n            tag,\n            attrs,\n            children: [],\n            parent: null,\n            type: ELEMENT_TYPE\n        }\n    }\n\n    /**\n     * 已经解析的标签置空\n     */\n\n    const advance = (n: number) => {\n        html = html.substring(n)\n    }\n\n    /**\n     * 判断是否为一个起始标签\n     */\n\n    const parseStartTag = () => {\n        const start = html.match(startTagOpen)\n        if (start) {\n            // <div><div><div/><div/> -> <div><div/><div/> -> <div/><div/>\n            const match: any = {\n                tag: [start[1]],\n                attrs: []\n            }\n            advance(start[0].length)\n            // 如果不是起始标签的结尾 一直匹配下去\n            let end, attr\n            while (\n                !(end = html.match(startTagClose)) &&\n                (attr = html.match(attribute))\n                ) {\n                // 匹配到属性 收集至attr数组中 截取原始的字符串\n                advance(attr[0].length)\n                match.attrs.push({\n                    key: attr[1],\n                    value: attr[3] || attr[4] || attr[5] || true,\n                })\n            }\n            if (end) {\n                advance(end[0].length)\n            }\n            return match\n        }\n        return false\n    }\n\n    /**\n     * 处理起始标签\n     * 创建AST Node\n     */\n\n    const start = (tag: string, attrs: []) => {\n        const node = createASTElement(tag, attrs)\n        if (!root) {\n            root = node\n        }\n        // 栈中有值 建立父子关系\n        if (currentParent) {\n            node.parent = currentParent\n            currentParent.children.push(node)\n        }\n        // 压入栈中，作为下一个元素的爹元素\n        stack.push(node)\n        currentParent = node\n    }\n\n    /**\n     * 处理结尾标签\n     */\n\n    const end = (tag) => {\n        stack.pop()\n        currentParent = stack[stack.length - 1]\n    }\n\n    /**\n     * 文本节点\n     */\n\n    const char = (text: string) => {\n        text = text.replace(/\\s/g, \"\");\n        // @ts-ignore\n        text &&\n        currentParent.children.push({\n            type: TEXT_TYPE,\n            parent: currentParent,\n            text,\n        });\n    }\n\n    while (html) {\n        let textEnd = html.indexOf(\"<\")\n        if (textEnd === 0) {\n            // 有可能是<div/>\n            const endTagMatch = html.match(endTag)\n            if (endTagMatch) {\n                advance(endTagMatch[0].length)\n                end(endTagMatch[1])\n                continue\n            }\n            // <div>\n            const startTagMatch = parseStartTag()\n            // 匹配到起始标签\n            if (startTagMatch) {\n                start(startTagMatch.tag,startTagMatch.attrs)\n                continue\n            }\n        }\n        // 文本节点\n        if (textEnd > 0) {\n            let text = html.substring(0, textEnd) // get文本内容\n            if (text) {\n                char(text)\n                advance(text.length)\n            }\n        }\n    }\n    return root\n}","/**\n * @file 模版解析引擎\n */\n\nimport {ASTNode, parseHTML} from \"./parseHtml\";\n\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g; //匹配花括号 {{  }} 捕获花括号里面的内容\n\nconst genProps = (attrs) => {\n    let tokens = \"\"\n    attrs.map(({key, value}) => {\n        if (key === 'style') {\n            // color: 'red'; margin-top: '20px';\n            let styleMap = {}\n            value.split(';').map(style => {\n                let [styleKey, styleVal] = style.split(':')\n                styleMap[styleKey] = styleVal\n            })\n            value = styleMap\n        }\n        tokens += `${key}:${JSON.stringify(value)},`\n    })\n    return tokens.slice(0, -1)\n}\n\n\nconst gen = (node) => {\n    // 不是叶子节点\n    if (node.type === 1) {\n        return codegen(node)\n    } else {\n        // 处理文本节点\n        let text = node.text\n        // 没有匹配到{{}}\n        if (!defaultTagRE.test(text)) {\n            return `_v(${JSON.stringify(text)})`\n        }\n        // 全局模式下，将正则匹配的lastIndex = 0 使其从头开始\n        let lastIndex = (defaultTagRE.lastIndex = 0)\n        let tokens = []\n        let match\n        // 匹配{{}}收集到token数组中\n        while ((match = defaultTagRE.exec(text))) {\n            let index = match.index\n            if (index > lastIndex) {\n                tokens.push(JSON.stringify(text.slice(lastIndex, index)))\n            }\n            tokens.push(`_s(${match[1].trim()})`)\n            lastIndex = index + match[0].length\n        }\n        if (lastIndex < text.length) {\n            tokens.push(JSON.stringify(text.splice(lastIndex)))\n        }\n        return `_v(${tokens.join(\"+\")})`\n    }\n}\n\n/**\n * 生成儿子\n */\n\nconst genChildren = (ast) => {\n    let {children} = ast || []\n    return `${children.map(item => gen(item)).join(',')}`\n}\n\n/**\n * 生成Code _v(div_c('yedi'))\n */\n\nconst codegen = (ast) => {\n    let children = genChildren(ast)\n    return `_c('${ast.tag}'${ast.attrs.length > 0 ? genProps(ast.attrs): ''}${ast.children.length > 0 ? `,${children}`: ''})`\n}\n\n/**\n * 生成render函数并挂载至vm实例下\n */\n\nexport const compileRenderFunction = function (template) {\n    let ast: ASTNode = parseHTML(template)\n    let code = codegen(ast)\n    code = `with(this){return ${code}}`\n    // let render = new Function(code)\n    // return render\n}","import {compileRenderFunction} from \"./src/parser/index\";\n\n\ncompileRenderFunction('<div id=\"root\" style=\"color: red; margin-top: 20px\">{{yedi}} <span>秋天的第一个offer</span>{{leyo}}</div>');"],"names":["attribute","ncname","qnameCapture","startTagOpen","RegExp","startTagClose","endTag","defaultTagRE","genChildren","ast","children","map","item","node","type","codegen","text","test","JSON","stringify","match","lastIndex","tokens","exec","index","push","slice","trim","length","splice","join","gen","tag","attrs","key","value","styleMap","split","style","styleKey","styleVal","genProps","template","html","stack","currentParent","root","advance","n","substring","parseStartTag","start","end","attr","parent","createASTElement","char","replace","textEnd","indexOf","endTagMatch","pop","startTagMatch","parseHTML","compileRenderFunction"],"mappings":"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"}